#!/usr/bin/env python
# Copyright (C) 2013, Elphel.inc.
# Generation of the C source file for u-boot lowlevel init
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
__author__ = "Andrey Filippov"
__copyright__ = "Copyright 2013, Elphel, Inc."
__license__ = "GPL"
__version__ = "3.0+"
__maintainer__ = "Andrey Filippov"
__email__ = "andrey@elphel.com"
__status__ = "Development"
#import ezynq_clk
class EzynqUBoot:
    license="""/*
 * This file is automatically generated by the Free Software program using open information from the
 * components datasheets, reference manuals and user data.
 * No license is required to distribute this file. User may select his/her own license to replace
 * this header text.
 */
 
"""
    # remove unneeded 
    include_section="""
#include <common.h>
#include <asm/io.h>
#include <asm/arch/sys_proto.h>
#include <asm/arch/hardware.h>

"""
    
    def __init__(self, verbosity):
        self.cfile=self.license + self.include_section
        self.verbosity=verbosity
        self.sections=['license','include'] 
    def get_c_file(self):
        return self.cfile
    def _opt_hex(self,d):
        if d <10:
            return str(d)
        else:
            return hex(d)
   
    def _add_reg_writes(self,reg_sets):
        for op, addr, data, mask, module_name, register_name, r_def in reg_sets:
            try:
                comments=r_def['COMMENTS']
            except:
                comments=''
            if op == 's':    
                self.cfile+='\twritel(0x%08x, 0x%08x); /* %s.%s  %s */\n'%(data,addr,module_name,register_name,comments)
            elif op == '=':
                self.cfile+='\twhile((readl(0x%08x) & %s) != %s); /* %s.%s  %s */\n'%(addr,self._opt_hex(mask),self._opt_hex(data),module_name,register_name,comments)
            elif op == '!':
                self.cfile+='\twhile((readl(0x%08x) & %s) == %s); /* %s.%s  %s */\n'%(addr,self._opt_hex(mask),self._opt_hex(data),module_name,register_name,comments)
            else:
                raise Exception('Invalid register operation "%s" specified for register 0x%08x, data=0x%08x, mask=0x%08x'%(op,addr,data,mask))        
    def make_slcr_lock_unlock(self, reg_sets):
        self.sections.append('slcr_lock_unlock_setup')
        self.cfile+="""
/* Lock SLCR registers - may be called after everything is done. */        
void lock_slcr(void) /*not to conflict with another slcr_lock() in u-boot
{
"""
        self._add_reg_writes(reg_sets[:1])        
        self.cfile+="""}
        
/* Unlock SLCR registers - SHOULD be called first before writing any SLCR registers. */        
void unlock_slcr(void) /*not to conflict with another slcr_unlock() in u-boot
{
"""
        self._add_reg_writes(reg_sets[1:])        
        self.cfile+='}\n'

    def make_led_on_off(self, reg_sets):
        self.sections.append('led_on_off')
        self.cfile+="""
/* Turn LED on/off for debugging of the early stages of boot process. */        
void led_on_off(int on) /*not to conflict with another slcr_lock() in u-boot
{
"""
        self.cfile+='\tif (on)'
        self._add_reg_writes(reg_sets[1:])
        self.cfile+='\telse'
        self._add_reg_writes(reg_sets[:1])
        self.cfile+='}\n'
     
#make_led_on_off     
# void led_off(void){
#     writel(0x00000200, &slcr_base->mio_pin[47]); /* LED off */
# }
# void led_on(void){
#     writel(0x00001201, &slcr_base->mio_pin[47]);  /* LED on */
# }
# 
# void poll_fifo_empty(void){
#     while ((readl(&uart1_base->channel_sts) & 0x8) ==0) ; /* wait transmitter buffer is empty */
# }
# 
# void poll_putc(int d){
#     led_off();
#     while ((readl(&uart1_base->channel_sts) & 0x10) !=0) ; /* wait transmitter buffer is not full */
#     led_on();
#     writel(d, &uart1_base->tx_rx_fifo);
# }
# void poll_puts(char * line){
#     int i=0;
#     while (line[i]!=0) poll_putc(line[i++]);
# }
     
     
     
                
    def registers_setup(self, reg_sets,clk,num_rbl_regs): #clk is an instance of ezynq_clk.EzynqClk
        self.sections.append('registers_setup')
        self.cfile+="""
/*
   Setup registers after control is passed from the ROM boot loader to the user code.
   %i registers are already set up using RBL register initialization feature
 */        
inline void register_setup(void)
{
"""%num_rbl_regs
        self._add_reg_writes(reg_sets)        
        self.cfile+='}\n\n'

    def pll_setup (self, reg_sets,clk): #clk is an instance of ezynq_clk.EzynqClk
        self.sections.append('pll_setup')
        self.cfile+='''/* Wait for PLLs locked:*/        
inline void pll_setup(void)
{
\t/* Wait for all used PLLs locked, then  release PLL bypass on each PLL */
'''
        self._add_reg_writes(reg_sets)            
        self.cfile+='}\n\n'

    def uart_init (self, reg_sets,clk):
        self.sections.append('uart_init')
        self.cfile+='''/* Initilize UART to output debug info during boot */        
inline void uart_init(void)
{
\t/* Wait for all used PLLs locked, then  release PLL bypass on each PLL */
'''
        self._add_reg_writes(reg_sets)            
        self.cfile+='}\n\n'


        
    def dci_calibration (self, reg_sets,ddr): #ddr is an instance of ezynq_ddr.EzynqDDR
        if len(reg_sets)==0:
            print 'No DCI calibration register data is provided, skipping generating dci_calibration()'
            return
        self.cfile+='''/* Calibrate DDR DCI, wait for completion */        
inline void dci_calibration(void)
{
\t/* Toggle active-low DCI reset, initialize DCI calibration, wait for DONE */
'''
        self.cfile+='}\n\n'
        self.sections.append('dci_calibration')


    def ddr_start (self, reg_sets,ddr): #ddr is an instance of ezynq_ddr.EzynqDDR
        if len(reg_sets)==0:
            print 'No DDR start data is provided, skipping generating ddr_start()'
            return
        self.cfile+='''/* Start DDRC, wait for initialization complete */        
inline void ddr_start(void)
{
'''
        self._add_reg_writes(reg_sets)
        self.cfile+='}\n\n'
        self.sections.append('ddr_start')


    def make_lowlevel_init (self):
            

        self.cfile+='''/* Initialize clocks, DDR memory, copy OCM to DDR */        
void lowlevel_init(void)
{
'''
        if 'uart_init' in self.sections:
            self.cfile+='''/* Initialize UART fdro debug information output */        
\tuart_init();
'''
            
        self.cfile+='''/*
   Unlock SLCR
 */
\tunlock_slcr();

/*
   Write PLL and clocks registers as the code is now completely loaded to the OCM and no
   peripherals are needed immediately 
 */
   
\tregister_setup();

/*
   Wait PLLs locked and turn off bypass - all clocks should have specified values now
 */  
\tpll_setup();

/*
   Calibrate DDR DCI impedance and wait for completion
 */  
\tdci_calibration();

/*
   Remove soft reset from DDR controller - that starts initialization. Wait for completion
 */  
\tddr_start();
/*
   Copy 3 pages of OCM from 0x00000.0x2ffff to DDR 0x4000000.0x402ffff
 */  
\tint * s= (int *) 0;
\tint * d= (int *) 0x4000000;
\twhile (s< ((int *)0x30000)) *d++=*s++;
/*
   Now jump to the same instruction in the DDR copy of the currently executed code in OCM
   Be careful not to call functions or access data stored in the 3 lower OCM pages.
   writel() is OK as it is just a macro, not a function call 
 */  
\tasm("add pc, pc, #0x4000000" );
/*
   Remap DDR to zero, FILTERSTART
 */
\twritel(0, &scu_base->filter_start);
/*
   Device config APB, unlock the PCAP
 */
\twritel(0x757BDF0D, &devcfg_base->unlock);
\twritel(0xFFFFFFFF, &devcfg_base->rom_shadow);
/*
   Now as the code is executed outside of the OCM it is possible to remap the 3 lower
   OCM pages to high memory. 
   OCM_CFG, Mask out the ROM, map ram into upper addresses
 */
\twritel(0x1F, &slcr_base->ocm_cfg);
/*
   Copy program memory that we are currently executing to low DRAM (0x0.0x2ffff)
   Not possible to call library memcpy() as it will try to access not-yet copied code
 */
\ts= (int *) 0x4000000;
\td= (int *) 0;
\twhile (d < ((int *) 0x30000)) *d++=*s++;
/*
   Continue with the original low-level init, Now we have 2 copies of the code again,
   currently executing somewhere above 0x4000000. But as soon as we will return
   from the call (execute 'bx lr') we'll get back to the low memory.
 */  
\t/* FPGA_RST_CTRL, clear resets on AXI fabric ports */
\twritel(0x0, &slcr_base->fpga_rst_ctrl);
\t/* TZ_DDR_RAM, Set DDR trust zone non-secure */
\twritel(0xFFFFFFFF, &slcr_base->trust_zone);
\t/* Set urgent bits with register */
\twritel(0x0, &slcr_base->ddr_urgent_sel);
\t/* Urgent write, ports S2/S3 */
\twritel(0xC, &slcr_base->ddr_urgent);
\tlock_slcr();
/*
   This code was called from low OCM, so return should just get back correctly
 */
}
'''

    def output_c_file(self,cname):
        if not cname:
            return
        print 'Writing generated u-boot lowlevel() function to ',cname
        c_out_file=open(cname,'w')
        c_out_file.write(self.cfile)
        c_out_file.close()
    